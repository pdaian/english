## Controlling Bitcoin

Run *bitcoind* or *bitcoin -server*. You can control it via the command-line or by HTTP-JSON-RPC commands.

You must create a bitcoin.conf configuration file setting an rpcuser and rpcpassword; see [[Running_Bitcoin]] for details.

Now run:
	$ ./bitcoind
	bitcoin server starting
	$ ./bitcoind help

A [[list of RPC calls|Original_Bitcoin_client/API_Calls_list]] will be shown.

	$ ./bitcoind getbalance
	2000.00000

## JSON-RPC

Running Bitcoin with the -server argument (or running bitcoind) tells it to function as a [HTTP JSON-RPC](http://json-rpc.org/wiki/specification) server, but 
[HTTP Basic access authentication](http://en.wikipedia.org/wiki/Basic_access_authentication) must be used when communicating with it, and, for security, by default, the server only accepts connections from other processes on the same machine.  If your HTTP or JSON library requires you to specify which 'realm' is authenticated, use 'jsonrpc'.

Bitcoin supports SSL (https) JSON-RPC connections beginning with version 0.3.14.  See the [[rpcssl wiki page|Enabling_SSL_on_original_client_daemon]] for setup instructions and a list of all bitcoin.conf configuration options.

To access the server you should find a [suitable library](http://json-rpc.org/wiki/implementations) for your language.

## Proper money handling

See the [[proper money handling page|Proper_Money_Handling_(JSON-RPC)]] for notes on avoiding rounding errors when handling bitcoin values.

## Python

Save the following file as jsonrpc.py.

<source lang="python">
import urllib
import decimal
import json

class JSONRPCException(Exception):
	def __init__(self, rpcError):
	Exception.__init__(self)
	self.error = rpcError
	
class ServiceProxy(object):
	def __init__(self, serviceURL, serviceName=None):
	self.__serviceURL = serviceURL
	self.__serviceName = serviceName

	def __getattr__(self, name):
	if self.__serviceName != None:
	name = "%s.%s" % (self.__serviceName, name)
	return ServiceProxy(self.__serviceURL, name)

	def __call__(self, *args):
	postdata = json.dumps({"method": self.__serviceName, 'params': args, 'id':'jsonrpc'})
	respdata = urllib.urlopen(self.__serviceURL, postdata).read()
	resp = json.loads(respdata, parse_float=decimal.Decimal)
	if resp[['error']] != None:
	raise JSONRPCException(resp[['error']])
	else:
	return resp[['result']]         
</source>

Python-jsonrpc automatically generates Python methods corresponding to the functions above.

<source lang="python">
	from jsonrpc import ServiceProxy
	
	access = ServiceProxy("http://user:password@127.0.0.1:8332")
	access.getinfo()
	access.listreceivedbyaddress(6)
	access.sendtoaddress("11yEmxiMso2RsFVfBcCa616npBvGgxiBX", 10)
</source>

## PHP

The [JSON-RPC PHP](http://jsonrpcphp.org/) library also makes it very easy to connect to Bitcoin.  For example:

<source lang="php">
	require_once 'jsonRPCClient.php';
	
	$bitcoin = new jsonRPCClient('http://user:pass@127.0.0.1:8332/');
	
	echo "<pre>\n";
  print_r($bitcoin->getinfo()); echo "\n";
  echo "Received: ".$bitcoin->getreceivedbylabel("Your Address")."\n";
  echo "</pre>";
</source>

### Precision

Because PHP has no option to JSON decode to accurate decimal class, you should internally use GMP. Treat each number like a large int with 8 decimal places (this can be trimmed for display).

You will need to get a [saner branch](https://github.com/genjix/bitcoin/tree/strrpc) and compile it. This treats every monetary value int64 8 decimal strings. So 1 BTC will be "100000000". Use PHP's GMP functions to manipulate these values accurately.

For converting between internal GMP numbers and display/user input, you can use these functions:
<source lang="php">
function numstr_to_internal($numstr)
{
	return bcmul($numstr, pow(10, 8), 0);
}
function internal_to_numstr($num, $precision=2)
{
	$repr = gmp_strval($num);
	return bcdiv($repr, pow(10, 8), $precision);
}

$a = gmp_init("100");
$b = gmp_init("3");
$res_internal = numstr_to_internal($res);
echo "<p>".$res_internal."</p>";
$res_display = internal_to_numstr($res_internal);
echo "<p>".$res_display."</p>";
</source>

If you need to do a decimal division in GMP, then GMP only supports integer division + a remainder. The work-around for this, is to use the bcmath module:
<source lang="php">
$a = gmp_init("100");
$b = gmp_init("3");
echo "<p>".bcdiv(gmp_strval($a), gmp_strval($b), 3)."</p>";
</source>

Note that bcdiv only uses strings.

## Java

The easiest way to tell Java to use HTTP Basic authentication is to set a default Authenticator:

<source lang="java">
	final String rpcuser ="...";
	final String rpcpassword ="...";
	
	Authenticator.setDefault(new Authenticator() {
	protected PasswordAuthentication getPasswordAuthentication() {
	return new PasswordAuthentication (rpcuser, rpcpassword.toCharArray());
	}
	});
</source>

Once that is done, any JSON-RPC library for Java (or ordinary URL POSTs) may be used to communicate with the Bitcoin server.

## Perl

The JSON::RPC package from CPAN can be used to communicate with Bitcoin.  You must set the client's credentials; for example:

<source lang="perl">
	use JSON::RPC::Client;
	use Data::Dumper;
	
	my $client = new JSON::RPC::Client;
	
	$client->ua->credentials(
	'localhost:8332', 'jsonrpc', 'user' => 'password'  # REPLACE WITH YOUR bitcoin.conf rpcuser/rpcpassword
	);
	
	my $uri = 'http://localhost:8332/';
	my $obj = {
	method  => 'getinfo',
	params  => [],
	};
	
	my $res = $client->call( $uri, $obj );
	
	if ($res){
	if ($res->is_error) { print "Error : ", $res->error_message; }
	else { print Dumper($res->result); }
	} else {
	print $client->status_line;
	}
</source>

## .NET (C#)
The communication with rpc service can be achieved using the standard httprequest/response objects.
A library for serialising and deserialising Json will make your life a lot easier:

* JayRock for .NET 4.0
* Json.Net for .NET 2.0 and above 

The following example uses Json.Net:

<source lang="csharp">
	HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create("http://localhost.:8332");
	webRequest.Credentials = new NetworkCredential("user", "pwd");
	/// important, otherwise the service can't desirialse your request properly
	webRequest.ContentType = "application/json-rpc";
	webRequest.Method = "POST";
	
	JObject joe = new JObject();
	joe.Add(new JProperty("jsonrpc", "1.0"));
	joe.Add(new JProperty("id", "1"));
	joe.Add(new JProperty("method", Method));
	// params is a collection values which the method requires..
	if (Params.Keys.Count == 0)
	{
	joe.Add(new JProperty("params", new JArray()));
	}
	else
	{
	JArray props = new JArray();
	// add the props in the reverse order!
	for (int i = Params.Keys.Count - 1; i >= 0; i--)
	{
	.... // add the params
	}
	joe.Add(new JProperty("params", props));
	}
	
	// serialize json for the request
	string s = JsonConvert.SerializeObject(joe);
	byte[] byteArray = Encoding.UTF8.GetBytes(s);
	webRequest.ContentLength = byteArray.Length;
	Stream dataStream = webRequest.GetRequestStream();
	dataStream.Write(byteArray, 0, byteArray.Length);
	dataStream.Close();
	
	
	WebResponse webResponse = webRequest.GetResponse();
	
	... // deserialze the response
</source>

## Command line (cURL)

You can also send commands and see results using [cURL](http://curl.haxx.se/) or some other command-line HTTP-fetching utility; for example:

<source lang="bash">
	curl --user user --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getinfo", "params": [] }' 
	-H 'content-type: text/plain;' http://127.0.0.1:8332/
</source>

You will be prompted for your rpcpassword, and then will see something like:

<source lang="javascript">
	{"result":{"balance":0.000000000000000,"blocks":59952,"connections":48,"proxy":"","generate":false,
	"genproclimit":-1,"difficulty":16.61907875185736,"error":null,"id":"curltest"}
</source>

[[!tag "Articles_using_content_from_the_old_wiki"]]
[[!tag "Technical"]]
[[!tag "Developer"]]
