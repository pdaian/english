

##Design goals

Fully decentralized, anonymous, secure identity.

A SIN ("Secure Identity Number" or "System Identification Number") is the unique record identifier by which this identity will be known.

Attributes:

* Ownership may be digitally proven
* Attach sequence of key-value pairs (public proof) and hashes (private proof) to your SIN record.
	* A merkle root exists in each record, for even more private proofs.
* Start as anonymous; opt out of anonymity by attaching identifying key-value pairs (real.name = "John Smith", gov.us.ssn = "123-45-6789").
* Disposable
* All key-value pair updates digitally signed by SIN owner (key holder)
* Third parties may offer digital attestions:
	* Identity Verification, Inc. digitally signs a SIN as passing their Not A Criminal/Level-1 check.
	* Big Auction Provider, Inc. digitally signs a SIN as having a certain reputation score, on their website.
	* Decentralized market users digitally sign one another's SINs, building a decentralized reputation
* Type-1 SINs:  have some creation cost, deterring spam.
* Type-1 SINs: Sacrifice may be digitally proven, bootstrapping root of trust from blockchain data

tl;dr: A “master public key” generated by the user forms the root of digital trust.

##Types of SINs

###Type 1 (persistent)

SIN_Type 0x01 (bitcoin main chain) or 0x11 (testnet)

Type-1 SINs are intentionally scarce resources, much like bitcoins themselves.  All Type-1 SINs must conform to the sacrifice protocol described in this specification, to be considered valid.

###Type 2 (ephemeral)

SIN_Type 0x02

Type-2 SINs may be generated at any time, without network activity, much like bitcoin addresses.

##Definitions

* MPK: Master Public Key.  ECDSA, using same curve as bitcoin (secp256k1).
* Hash160: ripemd160(sha256(data))
* base58_encode_check: see bitcoin source code, https://github.com/bitcoin/bitcoin/blob/master/src/base58.h

##Creating a SIN

1. Prefix = 0x0F
1. SIN_Type =   [0x02 ](0x01) -- See above for discussion of SIN types.
1. MD = Hash160(MPK)
1. SIN = base58_encode_check( Prefix + SIN_Version + MD )
1. Hyphenate SIN for easier human reading if desired, inserting one hyphen after every 5th character.


For example, using the compressed public key:

<code>
02F840A04114081690223B7069071A70D6DABB891763B638CC20C7EC3BD58E6C86
</code>


Step 1 (SHA-256 of public key):

<code>
	 cb05d0fd5e76ba8ea88323fc5d3eefd09a78d8e2a5fd4955307b549657a31330
</code>

Step 2 (RIPEMD-160 of Step 1):

<code>
	 cb1f4a4d793731842732c153b8e9923bdb462553
</code>

Step 3 (Prefix + SIN_Version + Step 2):

<code>
	 0F02cb1f4a4d793731842732c153b8e9923bdb462553
</code>

Step 4 (Double SHA-256 of Step 3):

<code>
	 1a4214cdd79f55883263be8118d571c112cd4dbc9f8542d30daebd1231b522e9
</code>

Step 5 (Checksum):

<code>
	 1a4214cd
</code>

Step 6 (Step 5 + Step 3):

<code>
	 0F02cb1f4a4d793731842732c153b8e9923bdb4625531a4214cd
</code>

SIN (Base58 encoded):

<code>
	 TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA
</code>

##Creating sacrifice transactions

Creation cost is attached to decentralized identity by means of sacrificing a small amount of value.

An implementation of [Announce/Commit Sacrifices](https://en.bitcoin.it/wiki/Fidelity_bonds#Announce.2FCommit_Sacrifices).  That author's feedback on this protocol was very helpful.

1. MPK = master ECDSA public key (compressed)
1. BH = current block height
1. Create and sign transaction T2. Broadcast if desired.
	1. must include Hash160(MPK) OP_TRUE anyone-can-spend output with value >= 0.001BTC
	1. nlocktime = BH + 144 blocks
	1. no more than 1000 bytes in size
1. Create, sign and broadcast transaction T1
	1. must include OP_RETURN serialized(T2) output as last txout

##Validating the root identity information

1. B1 = block w/ T1
1. B2 = block w/ T2
1. Verify B2 height - 144 >= B1 height.
1. Verify announced T2 is valid
1. Verify mined T2 spends same inputs as announced T2 (not equal to account for [[Transaction_Malleability]])
1. Fail and waste sacrifice if not.


Thus a minimal root record is MPK and is provably

* linked to the sacrifices
* MPK starts a new chain of digital signature trust, for further record updates

##SIN record

A SIN record is a series of hashes or key/value pairs, validated by MPK digital signature.  Each SIN record has a stable binary encoding designed to ensure stable hash values.  This scheme is intentionally mirroring bitcoin's block header/merkle scheme.

Data types:

* uint32_t: an unsigned, little endian integer
* uint256_t: bitcoin-like 256-bit hash value

Layout of a SIN record:

* uint32_t magic number (and/or version number) == 0x88, 0x41, 0x92, 0xA4
* uint256_t merkle root
* uint32_t data record count
* [of data records](list)
* Signature

Layout of a data record:

* uint32_t: record type (== 0x1 for hash, 0x2 for key/value pair)
* [record-specific data](data)

Layout of a hash data record:

* [bytes of hash data](32)

Layout of a key/value data record:

* uint32_t key length
* uint32_t value length
* [UTF8-encoded key](key-length)
* [opaque data](value-length)

Duplicate keys are not permitted.

##Implementations

See:

* https://github.com/gasteve/node-libcoin/blob/master/SIN.js
* https://github.com/gasteve/node-libcoin/blob/master/SINKey.js
* https://github.com/ionux/phactor/blob/master/src/Sin.php

##Future work

After creation, the root identity and key-value pairs must be stored $somewhere.

After that root identity is created, additional key-value pairs may be associated with the root record via updates verified by MPK, stored in an alt-blockchain or DHT somewhere.  That is outside the scope of this minimal document, at this time.

Key attributes of this system, like price and transaction size, are hardcoded.  It is presumed that version 2+ will improve upon this, once field experience is gained and lessons are learned.
